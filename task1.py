import itertools
import time


def find_coins_greedy(
    amount, coins=[50, 25, 10, 5, 2, 1]
):  # За замовчуванням використовуються ці номінали монет
    """Функція жадібного алгоритму для видачі решти."""

    result = {}  # Результуючий словник для зберігання кількості монет кожного номіналу

    # Проходимо по кожному номіналу, починаючи з найбільшого
    for coin in coins:
        if amount >= coin:  # Перевіряємо, чи можемо використати цей номінал
            result[coin] = amount // coin  # Кількість монет цього номіналу
            amount %= coin  # Оновлюємо залишок суми

    return result


def find_min_coins(amount, coins=[50, 25, 10, 5, 2, 1]):
    """Функція динамічного програмування для видачі решти з мінімальною кількістю монет."""

    # Ініціалізуємо список для зберігання мінімальної кількості монет для кожної суми.
    # Спочатку всі значення ініціалізуються як 'float("inf")' (нескінченність),
    # оскільки ми ще не знаємо, скільки монет потрібно для кожної суми.
    min_coins = [float("inf")] * (amount + 1)
    min_coins[0] = 0  # Нульова сума не потребує монет

    # Ініціалізуємо список для зберігання номіналів монет, щоб зберігати,
    # які монети використовуються для досягнення кожної суми.
    coin_used = [0] * (amount + 1)

    # Зовнішній цикл перебирає всі суми від 1 до 'amount'.
    for s in range(1, amount + 1):
        # Внутрішній цикл перебирає всі доступні монети.
        for coin in coins:
            if s >= coin:
                # Перевіряємо, чи можна досягти суми 's' з меншою кількістю монет, ніж вже відомо.
                # Якщо min_coins[s] більше, ніж min_coins[s - coin] + 1, це означає, що
                # використання монети 'coin' для отримання суми 's' дає меншу кількість монет.
                if min_coins[s] > min_coins[s - coin] + 1:
                    # Оновлюємо мінімальну кількість монет для суми 's'.
                    min_coins[s] = min_coins[s - coin] + 1
                    # Зберігаємо номінал монети, яку використовуємо для досягнення цієї суми.
                    coin_used[s] = coin

    # Щоб відновити, які монети були використані для отримання 'amount', використовуємо
    # список 'coin_used', який містить номінали монет для кожної суми.
    result = {}
    current_amount = amount
    # Проходимо від 'amount' до 1, відновлюючи номінали монет для кожної суми.
    while current_amount > 0:
        # Отримуємо номінал монети, яку використовуємо для досягнення суми 'current_amount'.
        coin = coin_used[current_amount]
        # Якщо монета вже є в словнику result, її кількість збільшується на 1.
        if coin in result:
            result[coin] += 1
        # Інакше, монету додаємо до словника зі значенням 1.
        else:
            result[coin] = 1
        # Оновлюємо суму, віднімаючи номінал монети.
        current_amount -= coin

    # Функція повертає словник result, який містить номінали монет і їх кількість.
    return result


def run_tests(amount):
    """Функція для тестування швидкодії обох алгоритмів."""
    print(f"\033[0;36mТестування для суми: \033[1;36m{amount}\033[0m")

    # Тестування жадібного алгоритму
    start_time = time.time()
    greedy_result = find_coins_greedy(amount)
    greedy_time = time.time() - start_time
    greedy_count = sum(greedy_result.values())  # Загальна кількість використаних монет
    print(f"\033[0;32mЖадібний алгоритм:\033[0m {greedy_count} {greedy_result}")
    print(
        f"\033[0;32mЧас виконання жадібного алгоритму:\033[0;33m {greedy_time:.6f}\033[0m секунд"
    )

    # Тестування алгоритму динамічного програмування
    start_time = time.time()
    dp_result = find_min_coins(amount)
    dp_time = time.time() - start_time
    dp_count = sum(dp_result.values())  # Загальна кількість використаних монет
    print(f"\033[0;34mДинамічне програмування:\033[0m {dp_count} {dp_result}")
    print(
        f"\033[0;34mЧас виконання алгоритму динамічного програмування:\033[0;33m {dp_time:.6f}\033[0m секунд"
    )

    print()


# Тестування для різних сум
for amount in [58, 100, 947, 1000, 2846, 10000, 62913, 100000, 1000000]:
    run_tests(amount)